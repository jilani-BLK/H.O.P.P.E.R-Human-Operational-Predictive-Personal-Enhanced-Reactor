"""
D√©tecteur intelligent de malwares avec IA
Combine d√©tection par signatures, machine learning et analyse comportementale
Communication transparente via ActionNarrator
"""

from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum
import hashlib
import json
from datetime import datetime
import asyncio
import math
import os
import shutil
import pickle

# Communication transparente
try:
    from src.communication import ActionNarrator, narrate_file_scan, ActionType, Action, Urgency
    HAS_NARRATOR = True
except ImportError:
    HAS_NARRATOR = False
    print("‚ö†Ô∏è ActionNarrator non disponible pour malware_detector")

# Machine Learning
from sklearn.ensemble import RandomForestClassifier, IsolationForest
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score
import numpy as np

# File analysis (optionnels)
try:
    import magic
    HAS_MAGIC = True
except ImportError:
    HAS_MAGIC = False

try:
    import ssdeep
    HAS_SSDEEP = True
except ImportError:
    HAS_SSDEEP = False


class ThreatLevel(Enum):
    """Niveaux de menace"""
    SAFE = "safe"
    SUSPICIOUS = "suspicious"
    LIKELY_MALWARE = "likely_malware"
    CONFIRMED_MALWARE = "confirmed_malware"
    CRITICAL = "critical"


class DetectionMethod(Enum):
    """M√©thodes de d√©tection"""
    SIGNATURE = "signature"
    FUZZY_HASH = "fuzzy_hash"
    ML_STATIC = "ml_static"
    HEURISTIC = "heuristic"
    ANOMALY = "anomaly"


@dataclass
class ThreatReport:
    """Rapport d'analyse de menace"""
    file_path: str
    is_malware: bool
    threat_level: ThreatLevel
    confidence: float  # 0.0-1.0
    threats_found: List[str] = field(default_factory=list)
    detection_methods: List[str] = field(default_factory=list)
    indicators: List[str] = field(default_factory=list)
    explanation: str = ""
    recommended_action: str = ""
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    scan_duration: float = 0.0
    
    def to_dict(self) -> Dict:
        """Conversion en dictionnaire"""
        return {
            "file_path": self.file_path,
            "is_malware": self.is_malware,
            "threat_level": self.threat_level.value,
            "confidence": self.confidence,
            "threats_found": self.threats_found,
            "detection_methods": self.detection_methods,
            "indicators": self.indicators,
            "explanation": self.explanation,
            "recommended_action": self.recommended_action,
            "timestamp": self.timestamp,
            "scan_duration": self.scan_duration
        }


@dataclass
class MalwareSignature:
    """Signature de malware connu"""
    hash_sha256: str
    hash_md5: str
    name: str
    category: str  # trojan, virus, ransomware, etc.
    severity: str
    description: str
    first_seen: str
    samples_count: int = 1


class SignatureDatabase:
    """Base de donn√©es de signatures de malwares"""
    
    def __init__(self, db_path: str = "data/antivirus/signatures.json"):
        self.db_path = Path(db_path)
        self.signatures: Dict[str, MalwareSignature] = {}
        self.fuzzy_hashes: Dict[str, str] = {}  # fuzzy_hash -> malware_name
        self.load_signatures()
    
    def load_signatures(self):
        """Charge les signatures depuis le disque"""
        if not self.db_path.exists():
            self.db_path.parent.mkdir(parents=True, exist_ok=True)
            self._save()
            return
        
        try:
            with open(self.db_path, 'r') as f:
                data = json.load(f)
                for sig_data in data.get('signatures', []):
                    sig = MalwareSignature(**sig_data)
                    self.signatures[sig.hash_sha256] = sig
                self.fuzzy_hashes = data.get('fuzzy_hashes', {})
        except Exception as e:
            print(f"Erreur chargement signatures: {e}")
    
    def _save(self):
        """Sauvegarde les signatures"""
        try:
            data = {
                'signatures': [vars(sig) for sig in self.signatures.values()],
                'fuzzy_hashes': self.fuzzy_hashes,
                'updated_at': datetime.now().isoformat()
            }
            with open(self.db_path, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            print(f"Erreur sauvegarde signatures: {e}")
    
    def check_file(self, file_path: str) -> Optional[MalwareSignature]:
        """V√©rifie si un fichier correspond √† une signature connue"""
        try:
            path = Path(file_path)
            if not path.exists():
                return None
            
            # Calcul hashs
            sha256_hash = self._calculate_hash(path, 'sha256')
            
            # Check signature exacte
            if sha256_hash in self.signatures:
                return self.signatures[sha256_hash]
            
            # Check fuzzy hash (si disponible)
            if HAS_SSDEEP:
                try:
                    fuzzy = ssdeep.hash_from_file(str(path))
                    for known_fuzzy, malware_name in self.fuzzy_hashes.items():
                        similarity = ssdeep.compare(fuzzy, known_fuzzy)
                        if similarity > 85:  # 85% de similarit√©
                            # Trouve la signature associ√©e
                            for sig in self.signatures.values():
                                if sig.name == malware_name:
                                    return sig
                except Exception:
                    pass
            
            return None
        except Exception as e:
            print(f"Erreur check signature: {e}")
            return None
    
    def _calculate_hash(self, file_path: Path, algorithm: str = 'sha256') -> str:
        """Calcule le hash d'un fichier"""
        hash_func = hashlib.sha256() if algorithm == 'sha256' else hashlib.md5()
        try:
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b''):
                    hash_func.update(chunk)
            return hash_func.hexdigest()
        except Exception:
            return ""
    
    def add_signature(self, signature: MalwareSignature, fuzzy_hash: Optional[str] = None):
        """Ajoute une nouvelle signature"""
        self.signatures[signature.hash_sha256] = signature
        if fuzzy_hash and HAS_SSDEEP:
            self.fuzzy_hashes[fuzzy_hash] = signature.name
        self._save()
    
    def update_signatures(self, signatures: List[Dict]):
        """Met √† jour les signatures en batch"""
        for sig_data in signatures:
            sig = MalwareSignature(**sig_data)
            fuzzy = sig_data.get('fuzzy_hash')
            self.add_signature(sig, fuzzy)


class MLMalwareDetector:
    """D√©tecteur ML pour malwares inconnus"""
    
    def __init__(self, model_path: Optional[str] = None):
        self.model: Optional[RandomForestClassifier] = None
        self.anomaly_detector: Optional[IsolationForest] = None
        self.model_path = Path(model_path) if model_path else Path("data/antivirus/ml_model.pkl")
        self.anomaly_path = Path("data/antivirus/anomaly_model.pkl")
        
        if self.model_path.exists():
            self.load_model()
        if self.anomaly_path.exists():
            self.load_anomaly_detector()
    
    def extract_features(self, file_path: str) -> np.ndarray:
        """Extrait les features d'un fichier pour ML (20 dimensions)"""
        try:
            path = Path(file_path)
            if not path.exists():
                return np.zeros(20)
            
            features = []
            
            # 1. Taille fichier (log)
            size = path.stat().st_size
            features.append(math.log10(size + 1))
            
            # 2-6. Analyse contenu
            with open(path, 'rb') as f:
                content = f.read(10000)  # Premiers 10KB
                
                # 2. Entropie Shannon
                entropy = self._calculate_entropy(content)
                features.append(entropy)
                
                # 3. Ratio bytes NULL
                null_ratio = content.count(b'\x00') / len(content) if content else 0
                features.append(null_ratio)
                
                # 4. Ratio bytes printable
                printable = sum(1 for b in content if 32 <= b <= 126)
                printable_ratio = printable / len(content) if content else 0
                features.append(printable_ratio)
                
                # 5. Pr√©sence MZ header (PE files)
                has_mz = 1 if content[:2] == b'MZ' else 0
                features.append(has_mz)
                
                # 6. Pr√©sence strings suspectes
                suspicious_strings = [
                    b'cmd.exe', b'powershell', b'WScript.Shell',
                    b'crypto', b'ransom', b'payload'
                ]
                suspicious_count = sum(
                    1 for s in suspicious_strings if s in content
                )
                features.append(suspicious_count)
            
            # 7. Extension suspecte
            suspicious_exts = {'.exe', '.dll', '.bat', '.cmd', '.vbs', '.js', '.ps1'}
            has_suspicious_ext = 1 if path.suffix.lower() in suspicious_exts else 0
            features.append(has_suspicious_ext)
            
            # 8. Extension double (document.pdf.exe)
            has_double_ext = 1 if len(path.suffixes) > 1 else 0
            features.append(has_double_ext)
            
            # 9. Nom suspect
            suspicious_names = ['crack', 'keygen', 'patch', 'activator', 'hack']
            has_suspicious_name = any(
                name in path.stem.lower() for name in suspicious_names
            )
            features.append(1 if has_suspicious_name else 0)
            
            # 10. Fichier cach√© (commence par .)
            is_hidden = 1 if path.name.startswith('.') and len(path.name) > 1 else 0
            features.append(is_hidden)
            
            # 11-20. Patterns binaires suppl√©mentaires
            with open(path, 'rb') as f:
                content = f.read(10000)
                
                # Ratios de diff√©rents bytes
                for byte_range in [(0, 32), (32, 64), (64, 128), (128, 192), (192, 256)]:
                    count = sum(1 for b in content if byte_range[0] <= b < byte_range[1])
                    ratio = count / len(content) if content else 0
                    features.append(ratio)
                
                # Patterns sp√©cifiques
                features.append(content.count(b'\xFF\xFF') / max(1, len(content) - 1))
                features.append(content.count(b'\x00\x00') / max(1, len(content) - 1))
                features.append(content.count(b'\x90\x90') / max(1, len(content) - 1))  # NOP sled
                features.append(content.count(b'\xCC') / len(content) if content else 0)  # INT3
                features.append(len(set(content)) / 256)  # Diversit√© bytes
            
            return np.array(features[:20])  # Exactement 20 features
            
        except Exception as e:
            print(f"Erreur extraction features: {e}")
            return np.zeros(20)
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calcule l'entropie Shannon"""
        if not data:
            return 0.0
        
        entropy = 0
        for i in range(256):
            p = data.count(bytes([i])) / len(data)
            if p > 0:
                entropy -= p * math.log2(p)
        return entropy
    
    def train(
        self,
        malware_samples: List[str],
        benign_samples: List[str],
        test_size: float = 0.2
    ) -> Dict[str, float]:
        """Entra√Æne le mod√®le ML"""
        print("Extraction features malwares...")
        X_malware = np.array([
            self.extract_features(path) for path in malware_samples
        ])
        y_malware = np.ones(len(malware_samples))
        
        print("Extraction features b√©nins...")
        X_benign = np.array([
            self.extract_features(path) for path in benign_samples
        ])
        y_benign = np.zeros(len(benign_samples))
        
        # Combine datasets
        X = np.vstack([X_malware, X_benign])
        y = np.concatenate([y_malware, y_benign])
        
        # Split train/test
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=test_size, random_state=42
        )
        
        # Entra√Æne RandomForest
        print("Entra√Ænement RandomForest...")
        self.model = RandomForestClassifier(
            n_estimators=100,
            max_depth=10,
            random_state=42,
            n_jobs=-1
        )
        self.model.fit(X_train, y_train)
        
        # Entra√Æne d√©tecteur d'anomalies
        print("Entra√Ænement IsolationForest...")
        self.anomaly_detector = IsolationForest(
            contamination=0.1,
            random_state=42,
            n_jobs=-1
        )
        self.anomaly_detector.fit(X_train)
        
        # √âvalue
        y_pred = self.model.predict(X_test)
        metrics = {
            'accuracy': accuracy_score(y_test, y_pred),
            'precision': precision_score(y_test, y_pred),
            'recall': recall_score(y_test, y_pred)
        }
        
        # Sauvegarde
        self.save_model()
        
        print(f"Entra√Ænement termin√©: {metrics}")
        return metrics
    
    def predict(self, file_path: str) -> Tuple[bool, float, List[str]]:
        """Pr√©dit si un fichier est malveillant
        
        Returns:
            (is_malware, confidence, methods_used)
        """
        if not self.model:
            return False, 0.0, []
        
        try:
            features = self.extract_features(file_path)
            features_reshaped = features.reshape(1, -1)
            
            # Pr√©diction RandomForest
            prediction = self.model.predict(features_reshaped)[0]
            probabilities = self.model.predict_proba(features_reshaped)[0]
            confidence = probabilities[1] if prediction == 1 else probabilities[0]
            
            methods = [DetectionMethod.ML_STATIC.value]
            
            # D√©tection anomalie (si disponible)
            if self.anomaly_detector:
                anomaly_pred = self.anomaly_detector.predict(features_reshaped)[0]
                if anomaly_pred == -1:  # Anomalie d√©tect√©e
                    methods.append(DetectionMethod.ANOMALY.value)
                    confidence = max(confidence, 0.7)  # Boost confiance
            
            return bool(prediction), float(confidence), methods
            
        except Exception as e:
            print(f"Erreur pr√©diction ML: {e}")
            return False, 0.0, []
    
    def save_model(self):
        """Sauvegarde le mod√®le entra√Æn√©"""
        try:
            self.model_path.parent.mkdir(parents=True, exist_ok=True)
            with open(self.model_path, 'wb') as f:
                pickle.dump(self.model, f)
            if self.anomaly_detector:
                with open(self.anomaly_path, 'wb') as f:
                    pickle.dump(self.anomaly_detector, f)
        except Exception as e:
            print(f"Erreur sauvegarde mod√®le: {e}")
    
    def load_model(self):
        """Charge le mod√®le depuis le disque"""
        try:
            with open(self.model_path, 'rb') as f:
                self.model = pickle.load(f)
        except Exception as e:
            print(f"Erreur chargement mod√®le: {e}")
    
    def load_anomaly_detector(self):
        """Charge le d√©tecteur d'anomalies"""
        try:
            with open(self.anomaly_path, 'rb') as f:
                self.anomaly_detector = pickle.load(f)
        except Exception as e:
            print(f"Erreur chargement anomaly detector: {e}")


class HeuristicAnalyzer:
    """Analyseur heuristique pour comportements suspects"""
    
    def analyze(self, file_path: str) -> Tuple[bool, float, List[str]]:
        """Analyse heuristique d'un fichier
        
        Returns:
            (is_suspicious, confidence, indicators)
        """
        indicators = []
        suspicion_score = 0.0
        
        try:
            path = Path(file_path)
            if not path.exists():
                return False, 0.0, []
            
            # 1. Extension double
            if len(path.suffixes) > 1:
                indicators.append(f"Extension double: {'.'.join(path.suffixes)}")
                suspicion_score += 0.3
            
            # 2. Nom suspect
            suspicious_names = ['crack', 'keygen', 'patch', 'activator', 'hack', 'loader']
            if any(name in path.stem.lower() for name in suspicious_names):
                indicators.append(f"Nom suspect: {path.stem}")
                suspicion_score += 0.2
            
            # 3. Fichier cach√© sans extension
            if path.name.startswith('.') and not path.suffix:
                indicators.append("Fichier cach√© sans extension")
                suspicion_score += 0.15
            
            # 4. Entropie √©lev√©e (crypt√©/pack√©)
            with open(path, 'rb') as f:
                content = f.read(10000)
                entropy = self._calculate_entropy(content)
                if entropy > 7.5:  # Tr√®s haute entropie
                    indicators.append(f"Entropie √©lev√©e: {entropy:.2f}/8.0")
                    suspicion_score += 0.25
            
            # 5. Type MIME ne correspond pas √† l'extension
            if HAS_MAGIC:
                mime_type = magic.from_file(str(path), mime=True)
                if path.suffix == '.pdf' and 'application/x-executable' in mime_type:
                    indicators.append(f"Type MIME suspect: {mime_type} pour {path.suffix}")
                    suspicion_score += 0.3
            
            # 6. Taille inhabituelle
            size = path.stat().st_size
            if size < 100:  # Tr√®s petit
                indicators.append(f"Fichier tr√®s petit: {size} bytes")
                suspicion_score += 0.1
            elif size > 100_000_000:  # Tr√®s gros (>100MB)
                indicators.append(f"Fichier tr√®s gros: {size / 1_000_000:.1f} MB")
                suspicion_score += 0.1
            
            is_suspicious = suspicion_score >= 0.4  # Seuil de suspicion
            confidence = min(suspicion_score, 1.0)
            
            return is_suspicious, confidence, indicators
            
        except Exception as e:
            print(f"Erreur analyse heuristique: {e}")
            return False, 0.0, []
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calcule l'entropie Shannon"""
        if not data:
            return 0.0
        entropy = 0
        for i in range(256):
            p = data.count(bytes([i])) / len(data)
            if p > 0:
                entropy -= p * math.log2(p)
        return entropy


class MalwareDetector:
    """D√©tecteur intelligent de malwares avec multi-couches et communication transparente"""
    
    def __init__(
        self,
        signatures_db: Optional[SignatureDatabase] = None,
        ml_detector: Optional[MLMalwareDetector] = None,
        llm_analyzer: Optional[Any] = None,
        narrator: Optional[Any] = None  # ActionNarrator optionnel
    ):
        self.signatures = signatures_db or SignatureDatabase()
        self.ml_detector = ml_detector or MLMalwareDetector()
        self.heuristic = HeuristicAnalyzer()
        self.llm = llm_analyzer
        
        # Communication transparente
        if HAS_NARRATOR and narrator is None:
            self.narrator = ActionNarrator(verbose=True, auto_approve_low_risk=True)
        else:
            self.narrator = narrator
        
        self.quarantine_dir = Path("data/antivirus/quarantine")
        self.quarantine_dir.mkdir(parents=True, exist_ok=True)
        self.quarantine_index = self.quarantine_dir / "index.json"
    
    async def scan_file(
        self,
        file_path: str,
        deep_scan: bool = True
    ) -> ThreatReport:
        """Analyse compl√®te d'un fichier avec narration transparente"""
        start_time = datetime.now()
        
        # Narration transparente de l'action
        if self.narrator and HAS_NARRATOR:
            narrate_file_scan(self.narrator, file_path)
        
        path = Path(file_path)
        if not path.exists():
            if self.narrator:
                print(f"‚ùå Fichier introuvable : {file_path}")
            
            return ThreatReport(
                file_path=file_path,
                is_malware=False,
                threat_level=ThreatLevel.SAFE,
                confidence=0.0,
                explanation="Fichier introuvable",
                recommended_action="V√©rifier le chemin"
            )
        
        # Couche 1: Signatures
        signature_match = self.signatures.check_file(file_path)
        if signature_match:
            duration = (datetime.now() - start_time).total_seconds()
            
            # Communication transparente du r√©sultat
            if self.narrator:
                print(f"\n‚ö†Ô∏è  **Menace D√©tect√©e !**")
                print(f"   Fichier : {file_path}")
                print(f"   Type : {signature_match.name}")
                print(f"   Confiance : 100%")
                print(f"   ‚ö° Recommandation : Mise en quarantaine imm√©diate")
            
            explanation = await self._generate_explanation(
                file_path=file_path,
                threat_level=ThreatLevel.CONFIRMED_MALWARE,
                threats=[signature_match.name],
                indicators=[f"Signature: {signature_match.name}"],
                detection_methods=[DetectionMethod.SIGNATURE.value]
            )
            return ThreatReport(
                file_path=file_path,
                is_malware=True,
                threat_level=ThreatLevel.CONFIRMED_MALWARE,
                confidence=1.0,
                threats_found=[signature_match.name],
                detection_methods=[DetectionMethod.SIGNATURE.value],
                explanation=explanation,
                recommended_action="QUARANTAINE IMM√âDIATE",
                scan_duration=duration
            )
        
        # Deep scan: ML + Heuristiques
        if not deep_scan:
            return ThreatReport(
                file_path=file_path,
                is_malware=False,
                threat_level=ThreatLevel.SAFE,
                confidence=0.95,
                explanation="Aucune signature trouv√©e (scan rapide)",
                recommended_action="Aucune action requise",
                scan_duration=(datetime.now() - start_time).total_seconds()
            )
        
        # Couche 2: ML
        ml_malware, ml_confidence, ml_methods = self.ml_detector.predict(file_path)
        
        # Couche 3: Heuristiques
        heuristic_suspicious, heuristic_conf, indicators = self.heuristic.analyze(file_path)
        
        # Agr√©gation r√©sultats
        is_malware = ml_malware or heuristic_suspicious
        confidence = max(ml_confidence, heuristic_conf)
        methods = ml_methods + ([DetectionMethod.HEURISTIC.value] if heuristic_suspicious else [])
        
        # D√©terminer niveau de menace
        if confidence >= 0.9:
            threat_level = ThreatLevel.LIKELY_MALWARE
            action = "Quarantaine recommand√©e"
        elif confidence >= 0.6:
            threat_level = ThreatLevel.SUSPICIOUS
            action = "V√©rifier source"
        else:
            threat_level = ThreatLevel.SAFE
            action = "Aucune action requise"
        
        # G√©n√©rer explication LLM
        explanation = await self._generate_explanation(
            file_path=file_path,
            threat_level=threat_level,
            threats=[],
            indicators=indicators,
            detection_methods=methods
        )
        
        duration = (datetime.now() - start_time).total_seconds()
        
        # Communication transparente du r√©sultat
        if self.narrator:
            if threat_level == ThreatLevel.SAFE:
                print(f"\n‚úÖ **Scan Termin√© : Aucune Menace D√©tect√©e**")
                print(f"   Fichier : {file_path}")
                print(f"   Confiance : {confidence:.0%}")
                print(f"   Vous pouvez utiliser ce fichier en toute s√©curit√©.")
            elif threat_level == ThreatLevel.SUSPICIOUS:
                print(f"\n‚ö†Ô∏è  **Fichier Suspect D√©tect√©**")
                print(f"   Fichier : {file_path}")
                print(f"   Niveau de confiance : {confidence:.0%}")
                print(f"   Recommandation : {action}")
                if indicators:
                    print(f"   Indicateurs :")
                    for ind in indicators[:3]:  # Top 3
                        print(f"      ‚Ä¢ {ind}")
            else:  # LIKELY_MALWARE
                print(f"\nüõë **Malware Probable D√©tect√© !**")
                print(f"   Fichier : {file_path}")
                print(f"   Confiance : {confidence:.0%}")
                print(f"   ‚ö° Recommandation : {action}")
        
        return ThreatReport(
            file_path=file_path,
            is_malware=is_malware,
            threat_level=threat_level,
            confidence=confidence,
            detection_methods=methods,
            indicators=indicators,
            explanation=explanation,
            recommended_action=action,
            scan_duration=duration
        )
    
    async def _generate_explanation(
        self,
        file_path: str,
        threat_level: ThreatLevel,
        threats: List[str],
        indicators: List[str],
        detection_methods: List[str]
    ) -> str:
        """G√©n√®re une explication en langage naturel"""
        
        # Explication par d√©faut (sans LLM)
        if threat_level == ThreatLevel.SAFE:
            return (
                "Ce fichier semble s√ªr. Analys√© avec plusieurs m√©thodes "
                "de d√©tection, aucune menace n'a √©t√© identifi√©e."
            )
        
        if threat_level == ThreatLevel.SUSPICIOUS:
            indicators_text = "\n‚Ä¢ ".join(indicators) if indicators else "Patterns suspects d√©tect√©s"
            return (
                f"Ce fichier pr√©sente des caract√©ristiques inhabituelles:\n"
                f"‚Ä¢ {indicators_text}\n\n"
                f"Je recommande de v√©rifier la source du fichier avant de l'ouvrir."
            )
        
        if threat_level == ThreatLevel.CONFIRMED_MALWARE and threats:
            return (
                f"‚ö†Ô∏è ATTENTION: Ce fichier est un malware connu!\n\n"
                f"Menace d√©tect√©e: {', '.join(threats)}\n\n"
                f"Je recommande FORTEMENT la quarantaine imm√©diate. "
                f"N'EX√âCUTEZ PAS ce fichier."
            )
        
        if threat_level == ThreatLevel.LIKELY_MALWARE:
            methods_text = ", ".join(detection_methods)
            indicators_text = "\n‚Ä¢ ".join(indicators) if indicators else "Patterns malveillants"
            return (
                f"‚ö†Ô∏è Ce fichier est probablement malveillant.\n\n"
                f"Indicateurs d√©tect√©s:\n‚Ä¢ {indicators_text}\n\n"
                f"M√©thodes de d√©tection: {methods_text}\n\n"
                f"Je recommande la quarantaine par pr√©caution."
            )
        
        # Fallback LLM (si disponible)
        if self.llm:
            try:
                prompt = f"""
                Analyse de s√©curit√© d'un fichier:
                - Fichier: {Path(file_path).name}
                - Niveau de menace: {threat_level.value}
                - Indicateurs: {', '.join(indicators)}
                - M√©thodes: {', '.join(detection_methods)}
                
                G√©n√®re une explication claire et rassurante pour l'utilisateur.
                """
                # Appel LLM (√† impl√©menter selon votre agent)
                # response = await self.llm.process_request(prompt)
                # return response
            except Exception as e:
                print(f"Erreur g√©n√©ration LLM: {e}")
        
        return f"Analyse termin√©e. Niveau de menace: {threat_level.value}"
    
    async def quarantine_file(
        self,
        file_path: str,
        report: ThreatReport
    ) -> bool:
        """Met un fichier en quarantaine"""
        try:
            source = Path(file_path)
            if not source.exists():
                return False
            
            # Nom unique pour quarantaine
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            quarantine_name = f"{timestamp}_{source.name}"
            quarantine_path = self.quarantine_dir / quarantine_name
            
            # Copie fichier
            shutil.copy2(source, quarantine_path)
            
            # Supprime permissions
            os.chmod(quarantine_path, 0o000)
            
            # Enregistre dans index
            self._update_quarantine_index(
                original_path=str(source),
                quarantine_path=str(quarantine_path),
                report=report
            )
            
            return True
            
        except Exception as e:
            print(f"Erreur quarantaine: {e}")
            return False
    
    def _update_quarantine_index(
        self,
        original_path: str,
        quarantine_path: str,
        report: ThreatReport
    ):
        """Met √† jour l'index de quarantaine"""
        try:
            # Charge index existant
            if self.quarantine_index.exists():
                with open(self.quarantine_index, 'r') as f:
                    index = json.load(f)
            else:
                index = {'files': []}
            
            # Ajoute entr√©e
            index['files'].append({
                'original_path': original_path,
                'quarantine_path': quarantine_path,
                'quarantined_at': datetime.now().isoformat(),
                'threat_report': report.to_dict()
            })
            
            # Sauvegarde
            with open(self.quarantine_index, 'w') as f:
                json.dump(index, f, indent=2)
                
        except Exception as e:
            print(f"Erreur mise √† jour index: {e}")
    
    async def restore_from_quarantine(
        self,
        quarantine_path: str,
        original_path: Optional[str] = None
    ) -> bool:
        """Restaure un fichier depuis la quarantaine (faux positif)"""
        try:
            q_path = Path(quarantine_path)
            if not q_path.exists():
                return False
            
            # Restaure permissions
            os.chmod(q_path, 0o644)
            
            if original_path:
                # Restaure √† l'emplacement original
                shutil.copy2(q_path, original_path)
                q_path.unlink()  # Supprime de quarantaine
            
            return True
            
        except Exception as e:
            print(f"Erreur restauration: {e}")
            return False
    
    def update_signatures(self, signatures: List[Dict]):
        """Met √† jour la base de signatures"""
        self.signatures.update_signatures(signatures)
    
    async def scan_directory(
        self,
        directory: str,
        recursive: bool = True,
        deep_scan: bool = True
    ) -> List[ThreatReport]:
        """Scanne un r√©pertoire entier"""
        results = []
        path = Path(directory)
        
        if not path.exists():
            return results
        
        pattern = "**/*" if recursive else "*"
        for file_path in path.glob(pattern):
            if file_path.is_file():
                report = await self.scan_file(str(file_path), deep_scan)
                results.append(report)
        
        return results
