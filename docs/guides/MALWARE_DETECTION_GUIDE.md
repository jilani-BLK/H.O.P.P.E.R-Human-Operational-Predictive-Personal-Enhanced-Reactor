# Guide du Détecteur de Malwares HOPPER

## Vue d'ensemble

Le détecteur de malwares HOPPER est un système de sécurité intelligent qui combine plusieurs techniques de détection :

- **Signatures** : Base de hashs MD5/SHA256 de malwares connus
- **Fuzzy Hashing** : Détection de variantes via similarité structurelle (ssdeep)
- **Machine Learning** : RandomForest entraîné sur features statiques
- **Détection d'anomalies** : IsolationForest pour menaces inconnues
- **Heuristiques** : Patterns suspects (extensions doubles, entropie, etc.)
- **LLM** : Explications en langage naturel (optionnel)

## Installation

```bash
# Dépendances de base
pip install -r requirements-security.txt

# Inclut:
# - scikit-learn (ML)
# - numpy (calculs)
# - python-magic (détection type MIME, optionnel)
# - ssdeep (fuzzy hashing, optionnel)
```

## Utilisation rapide

```python
import asyncio
from src.security import MalwareDetector

async def scan_file():
    detector = MalwareDetector()
    result = await detector.scan_file("suspicious.exe", deep_scan=True)
    
    print(f"Malware: {result.is_malware}")
    print(f"Niveau: {result.threat_level.value}")
    print(f"Confiance: {result.confidence:.1%}")
    print(f"\n{result.explanation}")
    print(f"\nRecommandation: {result.recommended_action}")

asyncio.run(scan_file())
```

## Niveaux de menace

### SAFE (Vert)
- Aucune menace détectée
- Analysé avec toutes les méthodes
- Confiance élevée (>95%)
- **Action** : Aucune

### SUSPICIOUS (Jaune)
- Indicateurs suspects détectés
- Confiance moyenne (60-90%)
- Exemples : extension double, nom suspect, entropie élevée
- **Action** : Vérifier la source

### LIKELY_MALWARE (Orange)
- Forte probabilité de malware
- ML + heuristiques convergent
- Confiance élevée (>90%)
- **Action** : Quarantaine recommandée

### CONFIRMED_MALWARE (Rouge)
- Signature correspondante trouvée
- Confiance maximale (100%)
- Malware connu identifié
- **Action** : QUARANTAINE IMMÉDIATE

### CRITICAL (Rouge foncé)
- Menace critique active
- Ransomware, rootkit, etc.
- Danger immédiat
- **Action** : Isolation totale + suppression

## Architecture de détection

### Couche 1 : Signatures (10ms)

```python
# Détection instantanée par hash
signature_db = SignatureDatabase()
match = signature_db.check_file("file.exe")

if match:
    print(f"Malware connu: {match.name}")
    print(f"Catégorie: {match.category}")
```

**Avantages** :
- Ultra rapide (<10ms)
- 100% de fiabilité
- Pas de faux positifs

**Limitations** :
- Uniquement malwares connus
- Nécessite mises à jour régulières

### Couche 2 : Fuzzy Hashing (50ms)

```python
# Détecte variantes par similarité
if HAS_SSDEEP:
    fuzzy = ssdeep.hash_from_file("file.exe")
    similarity = ssdeep.compare(fuzzy, known_hash)
    
    if similarity > 85:
        print("Variante de malware détectée")
```

**Avantages** :
- Détecte variantes modifiées
- Résistant aux changements mineurs
- ~85% de confiance

**Limitations** :
- Nécessite ssdeep installé
- Plus lent que signature exacte

### Couche 3 : Machine Learning (100-200ms)

```python
# Prédiction sur features statiques
ml_detector = MLMalwareDetector()
features = ml_detector.extract_features("file.exe")
# 20 features: taille, entropie, headers, patterns...

is_malware, confidence, methods = ml_detector.predict("file.exe")
```

**Features extraites (20 dimensions)** :
1. Taille fichier (log)
2. Entropie Shannon
3. Ratio bytes NULL
4. Ratio bytes printable
5. Présence MZ header
6. Strings suspectes
7. Extension suspecte
8. Extension double
9. Nom suspect
10. Fichier caché
11-15. Ratios bytes par plages
16-20. Patterns binaires (NOP, INT3, diversité)

**Modèle** :
- RandomForest (100 arbres)
- Précision : ~95%+
- Rappel : ~92%+
- F1-Score : ~93%+

### Couche 4 : Heuristiques (50ms)

```python
# Détection par patterns suspects
heuristic = HeuristicAnalyzer()
is_suspicious, confidence, indicators = heuristic.analyze("file.exe")

# Exemples d'indicateurs:
# - Extension double: .pdf.exe
# - Nom suspect: crack, keygen
# - Entropie > 7.5 (crypté)
# - MIME mismatch (PDF contenant exécutable)
# - Taille inhabituelle (<100 bytes ou >100MB)
```

### Couche 5 : Détection d'anomalies (100ms)

```python
# IsolationForest pour comportements inhabituels
anomaly_detector = IsolationForest()
prediction = anomaly_detector.predict(features)

if prediction == -1:
    print("Anomalie détectée (menace zero-day possible)")
```

**Utilité** :
- Détecte menaces inconnues
- Pas de signatures nécessaires
- Alerte sur comportements anormaux

**Attention** :
- Plus de faux positifs
- Complément aux autres méthodes

### Couche 6 : LLM (variable)

```python
# Explication en langage naturel
from src.agent import LLMAgent

agent = LLMAgent()
detector = MalwareDetector(llm_analyzer=agent)
result = await detector.scan_file("file.exe")

print(result.explanation)
# "⚠️ Ce fichier présente des caractéristiques suspectes.
#  L'extension double (.pdf.exe) est une technique courante
#  utilisée par les malwares pour tromper l'utilisateur..."
```

## Entraînement du modèle ML

### Préparer le dataset

```python
# Collecter échantillons
malware_samples = [
    "samples/malware/trojan1.exe",
    "samples/malware/virus1.dll",
    # ... 5,000+ échantillons
]

benign_samples = [
    "samples/benign/document1.pdf",
    "samples/benign/app1.exe",
    # ... 10,000+ échantillons
]
```

**Sources recommandées** :
- **VirusTotal** : Base publique de malwares
- **CIRCL** : Threat Intelligence
- **AV-TEST** : Samples de test
- **Système** : Fichiers légitimes locaux

### Entraîner

```python
from src.security import MLMalwareDetector

detector = MLMalwareDetector()

metrics = detector.train(
    malware_samples=malware_samples,
    benign_samples=benign_samples,
    test_size=0.2  # 20% pour validation
)

print(f"Accuracy: {metrics['accuracy']:.1%}")
print(f"Precision: {metrics['precision']:.1%}")
print(f"Recall: {metrics['recall']:.1%}")
```

**Métriques cibles** :
- Accuracy : >95%
- Precision : >95% (peu de faux positifs)
- Recall : >92% (détecte la plupart des malwares)

### Mise à jour régulière

```python
# Réentraîner mensuellement
# Les malwares évoluent constamment!

import schedule

def retrain_model():
    new_malware = fetch_new_malware_samples()
    detector.train(new_malware, benign_samples)

schedule.every().month.do(retrain_model)
```

## Gestion de la quarantaine

### Mettre en quarantaine

```python
# Après détection
result = await detector.scan_file("suspect.exe")

if result.threat_level in [ThreatLevel.LIKELY_MALWARE, ThreatLevel.CONFIRMED_MALWARE]:
    # Demander confirmation utilisateur
    if user_confirms():
        success = await detector.quarantine_file("suspect.exe", result)
        if success:
            print("✓ Fichier en quarantaine")
```

**Processus** :
1. Copie vers `data/antivirus/quarantine/`
2. Permissions supprimées (chmod 0o000)
3. Enregistrement dans index.json
4. Original peut être supprimé (optionnel)

### Restaurer (faux positif)

```python
# Si détection incorrecte
await detector.restore_from_quarantine(
    quarantine_path="data/antivirus/quarantine/20251023_143052_file.exe",
    original_path="/path/to/restore/file.exe"
)
```

### Structure de quarantaine

```
data/antivirus/quarantine/
├── index.json
├── 20251023_143052_suspect.exe
├── 20251023_145523_malware.dll
└── 20251024_091234_trojan.bat
```

**index.json** :
```json
{
  "files": [
    {
      "original_path": "/downloads/suspect.exe",
      "quarantine_path": "data/antivirus/quarantine/20251023_143052_suspect.exe",
      "quarantined_at": "2025-10-23T14:30:52",
      "threat_report": {
        "threat_level": "likely_malware",
        "confidence": 0.92,
        "threats_found": [],
        "indicators": ["Extension double", "Entropie élevée"],
        "explanation": "..."
      }
    }
  ]
}
```

## Mise à jour des signatures

### Ajouter une signature

```python
from src.security import MalwareSignature

signature = MalwareSignature(
    hash_sha256="abc123...",
    hash_md5="def456...",
    name="Trojan.NewThreat.2025",
    category="trojan",
    severity="confirmed_malware",
    description="Nouvelle variante détectée",
    first_seen="2025-10-23",
    samples_count=150
)

detector.signatures.add_signature(signature)
```

### Batch update

```python
# Depuis source externe
new_signatures = [
    {
        "hash_sha256": "abc...",
        "hash_md5": "def...",
        "name": "Trojan.Test1",
        "category": "trojan",
        "severity": "confirmed_malware",
        "description": "...",
        "first_seen": "2025-10-23",
        "samples_count": 1
    },
    # ... plus de signatures
]

detector.update_signatures(new_signatures)
```

### Automatiser les mises à jour

```python
import requests
import schedule

def update_signatures_daily():
    # Exemple avec source externe
    response = requests.get("https://threat-intel.example.com/signatures.json")
    signatures = response.json()
    detector.update_signatures(signatures)
    print(f"✓ {len(signatures)} signatures mises à jour")

schedule.every().day.at("03:00").do(update_signatures_daily)
```

## Scan de répertoires

```python
# Scan récursif
results = await detector.scan_directory(
    directory="/downloads",
    recursive=True,  # Sous-dossiers
    deep_scan=True   # ML + heuristiques
)

# Statistiques
safe = [r for r in results if r.threat_level == ThreatLevel.SAFE]
suspicious = [r for r in results if r.threat_level == ThreatLevel.SUSPICIOUS]
malware = [r for r in results if r.is_malware]

print(f"Scannés: {len(results)}")
print(f"Sûrs: {len(safe)}")
print(f"Suspects: {len(suspicious)}")
print(f"Malwares: {len(malware)}")
```

## Intégration avec Agent LLM

```python
from src.agent import LLMAgent
from src.security import MalwareDetector

# Initialiser
agent = LLMAgent()
detector = MalwareDetector(llm_analyzer=agent)

# L'agent peut maintenant:
# 1. Générer des explications naturelles
result = await detector.scan_file("file.exe")
print(result.explanation)  # LLM-powered

# 2. Automatiser la surveillance
await agent.process_request(
    "Scanne tous les fichiers téléchargés cette semaine "
    "et génère un rapport de sécurité"
)

# 3. Répondre aux questions
await agent.process_request(
    "Ce fichier est-il sûr? Explique pourquoi."
)
```

## Performance

### Benchmarks typiques

| Méthode | Temps | Fiabilité |
|---------|-------|-----------|
| Signature | <10ms | 100% |
| Fuzzy hash | ~50ms | 85% |
| ML statique | 100-200ms | 95% |
| Heuristiques | ~50ms | 70-80% |
| Anomalies | ~100ms | 60-70% |
| **Total (deep)** | **200-400ms** | **>95%** |

### Optimisations

```python
# Scan rapide pour fichiers connus sûrs
if file_in_whitelist(path):
    return ThreatReport(threat_level=ThreatLevel.SAFE)

# Cache des résultats
cache = {}
file_hash = hashlib.sha256(file_content).hexdigest()
if file_hash in cache:
    return cache[file_hash]

# Batch processing
results = await detector.scan_directory(
    directory="/downloads",
    recursive=False,  # Plus rapide
    deep_scan=False   # Signatures seulement
)
```

## Bonnes pratiques

### 1. Demander confirmation

```python
# TOUJOURS demander avant d'agir
if result.is_malware:
    print(result.explanation)
    print(f"Recommandation: {result.recommended_action}")
    
    if input("Mettre en quarantaine? (o/n): ").lower() == 'o':
        await detector.quarantine_file(path, result)
```

### 2. Logger les actions

```python
import logging

logging.info(f"Scan: {path}")
logging.info(f"Résultat: {result.threat_level.value}")
logging.info(f"Méthodes: {result.detection_methods}")

if result.is_malware:
    logging.warning(f"MALWARE DÉTECTÉ: {path}")
```

### 3. Mettre à jour régulièrement

- Signatures : **quotidien**
- Modèle ML : **mensuel**
- Dépendances : **hebdomadaire**

### 4. Surveiller les faux positifs

```python
# Si trop de faux positifs
if result.threat_level == ThreatLevel.SUSPICIOUS:
    # Demander feedback utilisateur
    is_false_positive = user_feedback()
    if is_false_positive:
        # Ajouter à whitelist
        whitelist.add(file_hash)
```

### 5. Combiner avec autres outils

```python
# Intégration système
import subprocess

# Scan antivirus système en parallèle
clamav_result = subprocess.run(["clamscan", path])
hopper_result = await detector.scan_file(path)

# Combiner résultats
if clamav_result.returncode != 0 or hopper_result.is_malware:
    print("ATTENTION: Menace détectée par au moins un scanner")
```

## Dépannage

### Problème : Imports optionnels non disponibles

```python
# Vérifier disponibilité
from src.security.malware_detector import HAS_MAGIC, HAS_SSDEEP

if not HAS_MAGIC:
    print("⚠️ python-magic non installé, détection MIME désactivée")
    
if not HAS_SSDEEP:
    print("⚠️ ssdeep non installé, fuzzy hashing désactivé")

# Installer si nécessaire
# pip install python-magic
# pip install ssdeep
```

### Problème : Modèle ML non entraîné

```python
if not detector.ml_detector.model:
    print("⚠️ Modèle ML non disponible")
    print("Entraîner avec: detector.ml_detector.train(...)")
    # Utilise uniquement signatures + heuristiques
```

### Problème : Trop de faux positifs

```python
# Ajuster seuils
class CustomHeuristic(HeuristicAnalyzer):
    def analyze(self, file_path):
        is_suspicious, confidence, indicators = super().analyze(file_path)
        
        # Seuil plus strict
        is_suspicious = confidence >= 0.6  # Au lieu de 0.4
        
        return is_suspicious, confidence, indicators
```

## Exemples avancés

### Surveillance temps réel

```python
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class MalwareScanner(FileSystemEventHandler):
    def __init__(self, detector):
        self.detector = detector
    
    async def on_created(self, event):
        if event.is_directory:
            return
        
        print(f"Nouveau fichier: {event.src_path}")
        result = await self.detector.scan_file(event.src_path)
        
        if result.is_malware:
            print(f"⚠️ MALWARE: {result.explanation}")
            # Alerte utilisateur

# Monitorer downloads/
observer = Observer()
observer.schedule(MalwareScanner(detector), path="/downloads", recursive=True)
observer.start()
```

### Rapports automatisés

```python
async def generate_security_report(detector, period_days=7):
    # Scan tous les fichiers récents
    results = []
    for path in get_recent_files(period_days):
        result = await detector.scan_file(path)
        results.append(result)
    
    # Générer rapport
    report = {
        "period": f"{period_days} jours",
        "total_scanned": len(results),
        "threats_found": sum(1 for r in results if r.is_malware),
        "suspicious": sum(1 for r in results if r.threat_level == ThreatLevel.SUSPICIOUS),
        "safe": sum(1 for r in results if r.threat_level == ThreatLevel.SAFE)
    }
    
    # Envoyer rapport
    print(json.dumps(report, indent=2))
    return report
```

## Références

- **VirusTotal** : https://www.virustotal.com/
- **YARA** : https://virustotal.github.io/yara/
- **ssdeep** : https://ssdeep-project.github.io/ssdeep/
- **scikit-learn** : https://scikit-learn.org/

## Support

Pour toute question ou problème :
1. Consulter les exemples : `examples/malware_detection_demo.py`
2. Vérifier les logs : `data/antivirus/quarantine/index.json`
3. Tester avec fichiers de test connus

---

**Note importante** : HOPPER détecte et alerte, mais ne prend **JAMAIS** d'action sans confirmation utilisateur. Votre contrôle est primordial.
